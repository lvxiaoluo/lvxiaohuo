| 题目名称                                                     | 标准答案                                                     | 1分                                         | 2分                                                          | 3分                                                          | 4分                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
| redis支持哪几种数据类型？                                    | String、List、Set、Sorted Set、hash                          | 可回答string、hash                          | string,hash,list                                             | 标准答案                                                     | 能讲解redis 的各种数据类型的数据结构，skipList 跳跃表 |
| 使用Redis有哪些好处？                                        | (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)(2) 支持丰富数据类型，支持string，list，set，Zset，hash等(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 | 简单的回答快                                | 能回答为什么快                                               | 能回答操作原子性，实现分布式锁                               | 分布式锁实现原理，可能存在的问题，以及解决方案        |
| Redis相比Memcached有哪些优势？                               | (1)Memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型(2) Redis的速度比Memcached快很多(3) Redis可以持久化其数据 | 不知道                                      | 不知道                                                       |                                                              | 知道                                                  |
| Memcache与Redis的区别都有哪些？                              | (1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。(2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。(3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 | 不知道                                      | 不知道                                                       |                                                              | 知道                                                  |
| Redis是单进程单线程的？                                      | Redis是单进程单线程的，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销 | 知道单进程                                  | 知道单进程，IO多路复用                                       | 零copy                                                       |                                                       |
| Redis适合的场景？                                            | （1）、会话缓存（Session Cache） 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。（2）、全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。（3）、队列 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。（4），排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。（5）、发布/订阅 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！ | 做缓存                                      | 其他数据类型，比如计算热点新闻的TOP                          | 知道redis 做消息队列的问题                                   |                                                       |
| 数据库和缓存的数据一致性如何保障，有哪些方案？               | A、 更新数据库同时更缓存– 并发场景不高如运营端变更或设置数据B、 通过消息来更新缓存 -- 时效性无法保证C、 通过mysql binlog 消息来更新缓存 | 不知道                                      | 先删除缓存，更新数据，等待下一次读取再缓存                   | 加载库，一个请求读，其他请求阻塞等待                         |                                                       |
| redis的数据类型，以及每种数据类型的使用场景                  | (一)String这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。(二)hash这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。(三)list使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。(四)set因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。(五)sorted setsorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作 | string,list,hash缓存                        | list做队列，set 去重                                         | list 做队列存在的问题，不能重复消费，sort set 排行榜         |                                                       |
| redis过期策略都有哪些？                                      | 定时过期(一key一定时器)，惰性过期：只有使用key时才判断key是否已过期，过期则清除。定期过期：前两者折中 | 定时过期                                    | 惰性过期，查询判断                                           |                                                              |                                                       |
| Redis的数据淘汰策略有哪些                                    | voltile-lru 从已经设置过期时间的数据集中挑选最近最少使用的数据淘汰voltile-ttl 从已经设置过期时间的数据库集当中挑选将要过期的数据voltile-random 从已经设置过期时间的数据集任意选择淘汰数据allkeys-lru 从数据集中挑选最近最少使用的数据淘汰allkeys-random 从数据集中任意选择淘汰的数据no-eviction 禁止驱逐数据 | 对设置过期的key 知道lru ,ttl                | 对所有的key 有淘汰策略                                       | 知道淘汰策略的过程                                           |                                                       |
| 缓存雪崩是什么？                                             | 缓存雪崩缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。解决办法：大多数系统设计者考虑用加锁（最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开 |                                             |                                                              |                                                              |                                                       |
| 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级             | 。二、缓存穿透缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。解决办法;最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap：典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。布隆过滤器（推荐）就是引入了k(k>1)k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。受提醒补充：缓存穿透与缓存击穿的区别缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。解决方案;在访问key之前，采用SETNX（set if  not  exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。增：给一个我公司处理的案例：背景双机拿token，token在存一份到redis，保证系统在token过期时都只有一个线程去获取token;线上环境有两台机器，故使用分布式锁实现。三、缓存预热缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！解决思路：1、直接写个缓存刷新页面，上线时手工操作下；2、数据量不大，可以在项目启动的时候自动进行加载；3、定时刷新缓存；四、缓存更新除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：（1）定时去清理过期的缓存；（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。五、缓存降级当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。以参考日志级别设置预案：（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户 | 不知道                                      | 知道基本概念                                                 | 知道解决方案                                                 | 知道设计时，通盘考虑，避免问题                        |
| 使用redis如何设计分布式锁？说一下实现思路？使用zk可以吗？如何实现？这两种有什么区别？ | redis:1.线程A setnx(上锁的对象,超时时的时间戳t1)，如果返回true，获得锁。2.线程B 用get获取t1,与当前时间戳比较,判断是是否超时,没超时false,若超时执行第3步;3.计算新的超时时间t2,使用getset命令返回t3(该值可能其他线程已经修改过),如果t1==t3，获得锁，如果t1!=t3说明锁被其他线程获取了。4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。zk:1.客户端对某个方法加锁时，在zk上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点node1;2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的node1的序号是最小的，就认为这个客户端获得了锁。3.如果发现node1不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。4.获取锁后，处理完逻辑，删除自己创建的node1即可。区别:zk性能差一些，开销大，实现简单 | 不知道                                      | 知道分布式锁的实现方案                                       | 知道各种分布式锁实现方案以及优缺点                           | 和其他分布式锁的优缺点对比                            |
| 如果有大量的key需要设置同一时间过期，一般需要注意什么？      | 如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。 | 不知道                                      | 知道随机设置过期时间                                         | 热点key 的预加载                                             | 热点key 的侦测                                        |
| 为什么要用 Redis 而不用 map/guava 做缓存?                    | 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 | 分布式和单机的区别                          | 知道各种优缺点                                               | 能结合使用场景，应该注意避免的问题                           |                                                       |
| Redis为什么这么快                                            | 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路 I/O 复用模型，非阻塞 IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； | 基于内存                                    | 基于内存，单线程，避免上下文                                 | 数据结构上讲解，不加锁，IO多路复用                           | 底层模型                                              |
| 分布式锁实现                                                 | 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 | 不知道                                      | 知道分布式环境共享数据的修改                                 | 实现过分布式锁                                               | 其他分布式锁实现方案的对比，优缺点                    |
| Redis持久化数据和缓存怎么做扩容？                            | 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 | 不知道                                      | 不知道                                                       | 一致性hash                                                   | 知道一致性hash存在的问题，以及解决方案                |
| Redis如何做内存优化？                                        | 可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面 | 设计小key                                   | 设置合理过期时间，及时淘汰                                   | 知道使用散列表                                               | 结合具体场景使用                                      |
| Redis线程模型                                                | Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。 参考：https://www.cnblogs.com/barrywxx/p/8570821.html | 单线程                                      | IO多路复用                                                   | IO多路复用，零copy                                           | 知道reactor                                           |
| redis 主从复制的核心原理                                     | 当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 | 不知道                                      | 知道bgsave,RDB                                               | 知道主从复制存在的问题，以及解决方案                         | 有实际应用场景，遇到问题，以及解决方案                |
| Redis中的管道有什么用？                                      | 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 |                                             |                                                              |                                                              |                                                       |
| Redis和Redisson有什么关系？                                  | Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 |                                             |                                                              |                                                              |                                                       |
| Redis在集群种查找key的时候，是怎么定位到具体节点的？         | 使用crc16算法对key进行hash 将hash值对16384取模，得到具体的槽位 根据节点和槽位的映射信息（与集群建立连接后，客户端可以取得槽位映射信息），找到具体的节点地址 去具体的节点找key 如果key不在这个节点上，则redis集群会返回moved指令，加上新的节点地址给客户端，同时，客户端会刷新本地的节点槽位映射关系 如果槽位正在迁移中，那么redis集群会返回asking指令给客户端，这是临时纠正，客户端不会刷新本地的节点槽位映射关系 |                                             |                                                              |                                                              |                                                       |
| Redis中的热key怎么处理？                                     | 对热key进行分散处理。比如：在key上加上不同的前后缀，缓存多个key，使得各个key分散到不同的节点上。 2、采用多级缓存 | 不知道                                      | 热key 分散到不同的节点                                       | 采用多级节点                                                 |                                                       |
| Redis中的大key怎么处理                                       | 大key指的是value特别大的key。比如很长的字符串，或者很大的set等等。 大key会造成2个问题：1、数据倾斜，比如某些节点内存占用过高。2、当删除大key或者大key自动过期的时候，会造成QPS突降，因为Redis是单线程的缘故。 处理方案：可以将一个大key进行分片处理，比如：将一个大set分成多个小的set。 | 能解释key对应的value 是很大的字符串，set 等 | 知道造成的问题，数据倾斜，比如某些节点内存占用过高。2、当删除大key或者大key自动过期的时候，会造成QPS突降 | 有解决方案，可以将一个大key进行分片处理，比如：将一个大set分成多个小的set。 |                                                       |
| 使用Redis统计网站的UV，应该怎么做                            | UV与PV不同，UV需要去重。一般有2种方案： 1、用BitMap。存的是用户的uid，计算UV的时候，做下bitcount就行了。 2、用布隆过滤器。将每次访问的用户uid都放到布隆过滤器中。优点是省内存，缺点是无法得到精确的UV。但是对于不需要精确知道具体UV，只需要大概的数量级的场景，是个不错的选择 | 能解释UV,PV 概念                            | 用BitMap。存的是用户的uid，计算UV的时候，做下bitcount就行了  | 用布隆过滤器。将每次访问的用户uid都放到布隆过滤器中。优点是省内存，缺点是无法得到精确的UV。但是对于不需要精确知道具体UV，只需要大概的数量级的场景，是个不错的选择 |                                                       |
| Redis事务机制了解过吗                                        | Redis事务的概念： Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　 Redis事务没有隔离级别的概念： 批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。 Redis不保证原子性： Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 Redis事务的三个阶段： 开始事务 命令入队 执行事务 Redis事务相关命令： watch key1 key2 ... : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ） multi : 标记一个事务块的开始（ queued ） exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　 discard : 取消事务，放弃事务块中的所有命令 unwatch : 取消watch对所有key的监控 | 能解释基本概念                              | 知道redis 事务没有隔离的概念，Redis不保证原子性              | Redis事务的三个阶段： 开始事务 命令入队 执行事务             |                                                       |
| Redis 集群方案什么情况下会导致整个集群不可用                 | 有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用 | 不知道                                      | 不知道                                                       | 在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用 |                                                       |
| Redis 哨兵模式数据丢失                                       | 1.异步复制导致的数据丢失2.脑裂导致的数据丢失解决方案：2.1 减少异步复制的数据丢失有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内。 2.2 减少脑裂的数据丢失如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求。 因此在脑裂场景下，最多就丢失10秒的数据。tails/113861243 | 不知道                                      | 知道异步复制，脑裂                                           | 知道基本基本解决方案                                         |                                                       |
| 缓存一致性                                                   | 数据实时同步对数据库数据进行更新的时候(新增、删除、更新)淘汰缓存(缓存失效) 读取数据的时候更新缓存，为了避免缓存击穿带来的雪崩问题我们需要做同步处理，控制只有一个线程去读取数据然后更新到缓存，其他线程被阻塞等待 设置缓存失效时间，这是一个兜底操作假设在更新缓存失败这个缓存失效时间一到就会把缓存失效数据准实时性对数据进行更新操作时在保持数据库后发送一个更新缓存的MQ消息(如果要保证数据不丢失，建议可以建立本地一个消息表在发生MQ失败后可以重试)缓存更新服务消费MQ更新数据消息后读取数据库数据进行相关业务处理(比如需要读取数据库数据进行汇总计算操作等)缓存更新服务更新业务处理结果数据到分布式缓存中任务调度更新 这种通过分布式调度任务进行定时更新缓存，使用场景如：报表统计数据、对账数据定时更新到缓存，实现比较简单 | 不知道                                      | 删除缓存，更新数据库，等待下一次数据加载                     | 知道删除缓存，等待下一次加载的问题，并且有解决方案           |                                                       |
| 谈谈你对Redis的理解?                                         | Redis是一种基于键值对的内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。提供了多种功能应用数据缓存功能，减少对数据库的访问压力，比如优化网站性能和一些不经常变动的数据消息队列功能: Redis提供了发布订阅功能和阻塞队列功能计数器-应用保存用户凭证比如计算浏览数，如果每次操作都要做数据库的对应更新操作，那将会给数据库的性能带来极大的挑战redis的应用场景场景有：缓存数据服务器比如SSO单点登录应对高速读写的场景比如秒杀高可用分布式锁比如秒杀数据一致性数据共享比如库存数据 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 为什么Redis要使用缓存？                                      | Redis使用缓存是为了实现高性能和高并发。Redis操作缓存就是直接操作内存，速度相当快，用户下一次再访问这些数据时可以直接从缓存中获取，以达到高性能的目的。缓存能够承受的请求数量是远远大于直接访问数据库的，数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存而不用经过数据库，以达到高并发的目的。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 如果有大量的key需要设置同一时间过期，一般需要注意什么？      | 如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis的常见数据类型以及使用场景？                            | String：用于需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。List：用于发布与订阅或者说消息队列、慢查询hash：用于系统中对象数据的存储Set：用于需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景sorted set（有序集合）：用于需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。bitmap：用于需要保存状态信息和需要进一步对这些信息进行分析的场景，比如用户签到情况、活跃用户情况、用户行为统计。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 使用Redis有哪些好处？                                        | 速度快，因为数据存在内存中.支持丰富数据类型，支持String，list，set，sorted set，hash 等支持事务，操作都是原子性应用场景丰富 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis为什么不适应多线程？                                    | 单线程编程容易并且更容易维护；Redis的性能瓶颈不在CPU上，主要在内存和网络；多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。Redis在6.0之后引入了多线程 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis的同步机制了解么？                                      | Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存中，待完成后将rdb文件同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis 的持久化机制是什么？                                   | Redis 提供两种持久化机制RDB和AOP机制:RDB持久化机制：是对redis中的数据执行周期性的持久化。AOP持久化机制： 是指所有的命令行记录以redis命令请求协议的格式完全持久化存储，保存为aof文件。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 是否使用过Redis集群，集群的原理是什么？                      | Redis Sentinal着眼于高可用，在maste 宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 说说Redis的缓存穿透？                                        | 缓存穿透就是大量请求的key根本不存在于缓存中，导致请求直接到了数据库上，没有经过缓存。缓存穿透的处理流程是：用户发送请求，系统首先判断缓存中是否存在对应的数据，如果缓冲中不存在，则到数据库中判断是否存在对应的数据，如果数据库没有数据则返回空。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 说一下Redis和Memcached的区别和共同点                         | 共同点 ：都是基于内存的数据库，一般都用来当做缓存使用。都有过期策略。两者的性能都非常高。区别 ：数据类型支持方面：Redis不仅仅支持简单的key/value类型的数据，同时还提供 list、set、sorted set、hash等数据结构的存储；Memcached只支持最简单的key/value数据类型。存储方式方面：Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；Memecache把数据全部存在内存之中。线程方面：Redis使用单线程的多路IO复用模型；Memcached是多线程，非阻塞IO复用的网络模型。应用场景方面：Redis支持发布订阅模型、会话存储、排行榜等功能，而Memcached不支持。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis的回收策略（淘汰策略）?                                 | volatile-lru方式：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰volatile-ttl方式：从已设置过期时间的数据集中挑选将要过期的数据淘汰volatile-random方式：从已设置过期时间的数据集中任意选择数据淘汰allkeys-lru方式：从数据集中挑选最近最少使用的数据淘汰allkeys-random方式：从数据集中任意选择数据淘汰no-enviction（驱逐）：禁止驱逐数据 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 为什么Redis需要把所有数据放到内存中？                        | Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis常见性能问题和解决方案：                                | Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网尽量避免在压力很大的主库上增加从主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Jedis与Redisson对比有什么优缺点？                            | Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson 的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis如何判断数据是否过期的？                                | Redis通过过期字典来保存数据过期的时间，过期字典的键指向Redis数据库中的某个key，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间。（辅助理解：过期字典可以看作是 hash 表） | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis支持的Java客户端都有哪些？官方推荐用哪个？              | Redisson、Jedis、lettuce等等，官方推荐使用Redisson。         | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis如何实现延时队列？                                      | 使用sorted set，将时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis集群方案什么情况下会导致整个集群不可用？                | 有 A、B、C 三个节点的集群，在没有复制模型的情况下，如果节点B 败了，那么整个集群就会缺少 5501-11000 这个范围的槽而不可用。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis key的过期时间和永久有效分别怎么设置？                  | expire命令设置过期时间，persist命令移除某个键的过期时间，也就是永久有效。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis中RDB持久化机制的优缺点？                               | 优点：只有一个文件dump.rdb方便持久化，可以用来做数据的冷备。rdb对redis的读写服务性能影响较小， 因为redis可以启动一个fork子进程来进行数据的持久化;rdb数据恢复更快， 因为rdb是一个数据文件， 恢复时直接放到内存里。缺点：rdb 因为保存数据的时间间隔比较大，因此会丢失更多的数据;如果数据量过大，由于需要进行数据保存， 可能服务会暂停较长时间 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis过期键的删除策略？                                      | 定时删除：在设置键的过期时间时创建一个定时器timer，让定时器在键过期的同时执行对键的删除操作。惰性删除：放任键过期不管，每次从键空间中获取键时，都检查取得的键是否过期，如果过期就删除该键，如果没有过期就返回该键。定期删除：每隔一段时间就对数据库进行一次检查，删除里面的过期键。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis集群的主从复制模型是怎样的？                            | 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品. | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis中AOP持久化机制的优缺点？                               | 优点：保存数据时间间隔为1 秒，数据丢失少;aof日志文件以append-only模式写入， 没有任何寻址开销，所以写入性能很快，即使文件尾部被破坏也可以很容易修复;aof有rewrite功能， 可以将容量大的aof文件进行压缩;缺点：AOF文件比RDB文件大，且恢复速度慢，当数据集大的时候，比rdb启动效率低。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis集群如何选择数据库？                                    | Redis 集群目前无法做数据库选择，默认在 0 数据库。            | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis6.0之后为何引入了多线程？                               | Redis6.0引入多线程主要是为了提高网络IO读写性能，但只在网络数据的读写这类耗时操作上使用， 执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。Redis6.0的多线程默认是禁用的，只使用主线程，开启需要修改redis配置文件redis.conf开启多线程后，还需要设置线程数，否则是不生效的 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis集群之间是如何复制的，最大节点个数是多少？              | Redis集群之间通过异步复制，最大节点个数为16384。             | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis回收进程如何工作的？                                    | 一个客户端运行了新的命令，添加了新的数据。Redis检查内存使用情况，如果大于最大内存的限制, 则根据设定好的策略进行回收。一个新的命令被执行,不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用，不用多久内存限制就会被这个内存使用量超越。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis集群会有写操作丢失吗？为什么？                          | Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis的内存用完了会发生什么？                                | 如果达到设置的上限，Redis的写命令会返回错误信息，但是读命令还可以正常返回。可以将Redis当缓存来使用配置淘汰机制，当内存达到上限时会冲刷掉旧的内容。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis有哪些应用场景？                                        | 最简单的就是缓存、用户登陆和校验码Redis提供的有序集合数据能构造排行榜功能，比如文章访问排行榜，月度销售排行榜等。Redis提供的incr命令可以用来实现计数器功能，比如视频的播放量，文章的浏览量等。Redis提供的发布/订阅和阻塞队列功能可以实现一个简单的聊天室。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis缓冲穿透的解决办法？                                    | 先进行参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端如果Redis缓存和数据库都查不到某个key，就将这个key写到Redis中并设置过期时间。使用布隆过滤器 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 怎么理解Redis事务？                                          | Redis 可以通过 MULTI，EXEC，DISCARD、WATCH等命令来实现事务功能，它提供了一种将多个命令请求打包的功能。然后再按顺序执行打包的所有命令，并且不会被中途打断。Redis的事务不支持rollback，因此不能满足原子性。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 说说Redis的单线程模型？                                      | Redis基于Reactor模式开发了文件事件处理器，该处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。文件事件处理器以单线程方式运行，实现了高性能的网络通信模型，可以很好地与Redis中的其他单线程模块进行对接。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 如果Redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ | redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿直到指令执行完毕，服务才能恢复。也可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 什么是Redis缓存雪崩？                                        | 缓存雪崩有两个场景Redis服务器不可用和热点缓存失效：Redis服务器不可用：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求而出现宕机。热点缓存失效：热点缓存在某一时刻大面积失效，导致对应的请求直接落到了数据库上。（辅助理解：被大量访问的数据=热点缓存） | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis如何保证缓存和数据库数据的一致性？                      | 让缓存数据的过期时间变短，这样就会从数据库中加载数据，但是不推荐，因为这种方式治标不治本。如果因为缓存服务当前不可用而导致缓存删除失败，可以隔一段时间进行重试，重试次数可以随意。如果多次重试还是失败的话，可以把当前更新失败的key存入队列中，等缓存服务可用之后，再将缓存中对应的key删除。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis缓存雪崩的解决方案？                                    | 针对Redis服务不可用的情况，可以采用Redis集群和限流来解决。针对热点缓存失效的情况，可以设置不同的失效时间或者设置缓存永不失效来解决。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务相关的命令有哪几个？                                | MULTI、EXEC、DISCARD、WATCH                                  | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis如何做内存优化？                                        | 尽可能使用散列表，因为散列表使用的内存非常小，所以应该尽可能的将数据模型抽象到一个散列表里面。比如web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 说说 Redis 哈希槽的概念？                                    | Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。 Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。 因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。 为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 说说Redis持久化？                                            | 1、什么是Redis持久化？持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失2、Redis 的持久化机制是什么？各自的优缺点？Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: RDB：是Redis DataBase缩写快照 RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期 优点： 1、只有一个文件 dump.rdb，方便持久化。2、容灾性好，一个文件可以保存到安全的磁盘。3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能4.相对于数据集大时，比 AOF 的启动效率更高。缺点： 1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。AOF：持久化 AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。   优点： 1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)缺点： 1、AOF 文件比 RDB 文件大，且恢复速度慢。2、数据集大的时候，比 rdb 启动效率低。优缺点是什么？ AOF文件比RDB更新频率高，优先使用AOF还原数据。AOF比RDB更安全也更大RDB性能比AOF好如果两个都配了优先加载AOF | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis持久化数据和缓存怎么做扩容？                            | 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis线程模型？                                              | Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 什么是事务？                                                 | 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务的概念                                              | Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务的三个阶段                                          | 1、事务开始 MULTI2、命令入队3、事务执行 EXEC事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务相关命令                                            | Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 1、redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。2、如果在一个事务中的命令出现错误，那么所有的命令都不会执行；3、如果在一个事务中出现运行错误，那么正确的命令会被执行。WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。UNWATCH命令可以取消watch对所有key的监控 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| 事务管理（ACID）概述                                         | 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。 隔离性（Isolation）多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务支持隔离性吗                                        | Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务保证原子性吗，支持回滚吗                            | Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |
| Redis事务其他实现                                            | 1、基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完2、基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐 | 能回答出来30%                               | 能回答出来60%                                                | 能回答70%                                                    | 能完整回答                                            |