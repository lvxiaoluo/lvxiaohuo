# 面试官：说说Redis之I/O多路复用模型实现原理



**你知道的越多，不知道的就越多，业余的像一棵小草！**

成功路上并不拥挤，因为坚持的人不多。



本文内容基于 Redis 6.0 以前的版本编写，因为 6.0 之后 Redis 在网络处理这一块采用了多线程模式，但是 I/O 多路复用的模型还在，变化不大。本文有不当之处，大家轻喷！

## Redis之I/O多路复用模型实现原理

Redis 的 I/O 多路复用模型有效的解决单线程的服务端，使用不阻塞方式处理多个 client 端请求问题。在看 I/O 多路复用知识之前，我们先来看看 Redis 的客服端怎么跟客服端建立连接的、单线程 socket 服务端为什么会存在 I/O 阻塞。

## Redis客户端连接

Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自 client 端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：

- 首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。
- 然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法。
- 然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送。

## 阻塞I/O

在 socket 连接中，一个服务器进程和一个客户端进行通信时，当一个 client 端向服务端写数据时，如果 client 端没有发送数据，那么服务端的 read 将一直阻塞，直到客户端 write 发来数据。在一个客户和服务器通信时没什么问题，当多个客户 与 一个服务器通信时，就存在问题了。如下图，两个客服端同时连接一个服务端进行写数据的时序图。

![图片](https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrcJNw52C7ic7NL7l3Hv8ok4M5OjibcibC8mtHuNRSlvxpUtF2hVHBmtRyT3TeYZlJZ6dDO2Pr39ibP85g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从上图可以看出一个服务器进程和多个客户端进程通信的问题：

- (1) client1 和服务端建立连接后，服务端会一直阻塞于 client1，直到 client1 客户端 write 发来数据才开始后面的操作。服务端阻塞期间，即使其他客服端 client2 的数据提前到来，也不能处理 client2 客服端的请求。
- (2) 有一个严重的问题就是，如果客户端 client1 一直没有 write 数据到来，那么服务端 service 会一直阻塞，不能处理其他客户的服务。

上面就是 Redis 通过 Unix socket 的方式来接收来自 client 端的连接存在的 I/O 阻塞问题，而 **「I/O 多路复用」**就是为了解决服务端一直阻塞等待某一个 client 的数据到来，即使其他client的数据提前到来，也不会被处理的问题。

## I/O多路复用

为什么 Redis 中要使用 I/O 多路复用这种技术呢？因为 Redis 是跑在**「单线程」**中的，所有的操作都是按照顺序线性执行的，但是**「由于读写操作等待用户输入 或 输出都是阻塞的」**，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导，致整个进程无法对其它客户提供服务。而 I/O 多路复用就是为了解决这个问题而出现的。**「为了让单线程(进程)的服务端应用同时处理多个客户端的事件，Redis 采用了 IO 多路复用机制。」**

这里**“多路”**「指的是多个网络连接客户端，」**“复用”**指的是复用同一个线程(单进程)。I/O 多路复用其实是使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流。如下图是 Redis 的 I/O 多路复用模型：

![图片](https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrcJNw52C7ic7NL7l3Hv8ok4MQ5COQvAqrricicLvw2pwMAE38s0Af1ibcSZB8YCl2kKrOK0kSbvmvfS6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

```
#1.文件描述符(file descriptor)：
    Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符。可以理解文件描述符是一个索引，这样，要操作文件的时候，我们直接找到索引就可以对其进行操作了。我们将这个索引叫做文件描述符（file descriptor），简称fd。
```

如上图对 Redis 的 I/O 多路复用模型进行一下描述说明：

- (1)一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。
- (2)多个客户端与服务端连接时，Redis 使用 **「I/O 多路复用程序」** 将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。当客服端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。
- (3)**「文件事件处理器」**使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 `accept`、`read`、`write` 和 `close` 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。

```
#例如：以 Redis 的 I/O 多路复用程序 epoll 函数为例
    多个客户端连接服务端时，Redis 会将客户端 socket 对应的 fd 注册进 epoll，然后 epoll 同时监听多个文件描述符(FD)是否有数据到来，如果有数据来了就通知事件处理器赶紧处理，这样就不会存在服务端一直等待某个客户端给数据的情形。

#（I/O多路复用程序函数有 select、poll、epoll、kqueue）
```

- (5)整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，当其中一个 client 端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现 I/O 堵塞的问题，提高了网络通信的性能。
- (6)如上图，Redis 的 I/O 多路复用模式使用的是 **「Reactor 设置模式」**的方式来实现。


#### 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。
![图片](https://img-blog.csdnimg.cn/20210323203354974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfY2p4,size_16,color_FFFFFF,t_70)
为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。

那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件，其实就是Redis会在select/epoll 机制上提前去注册Redis自己提供的回调函数。

这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。
为了方便你理解，我再以连接请求和读数据请求为例，具体解释一下。

这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。

另外Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。


- (1) Redis 的 I/O 多路复用程序函数有 select、poll、epoll、kqueue。select 作为备选方案，由于其在使用时会扫描全部监听的文件描述符，并且只能同时服务 1024 个文件描述符，所以是备选方案。
- (2) I/O 多路复用模型是利用 select、poll、epoll 函数可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉。当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量无用的等待操作。